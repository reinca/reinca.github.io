<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>먼저 해두고 싶은 것들 (Rev. 2) | My Rakugaki for</title>
<meta name="keywords" content="shoutout" />
<meta name="description" content="오픈월드형 레고를 만들려면, 나처럼 나이가 든 사람은 객체 우선이 아니라 레고판이 우선이다. 얇은 녹색판.">
<meta name="author" content="">
<link rel="canonical" href="https://www.karkador.net/post/4th-my_standard/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css" integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw&#43;W8mWdq36u97PLc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://www.karkador.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.karkador.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.karkador.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.karkador.net/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.karkador.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="먼저 해두고 싶은 것들 (Rev. 2)" />
<meta property="og:description" content="오픈월드형 레고를 만들려면, 나처럼 나이가 든 사람은 객체 우선이 아니라 레고판이 우선이다. 얇은 녹색판." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.karkador.net/post/4th-my_standard/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-24T08:50:42&#43;09:00" />
<meta property="article:modified_time" content="2021-09-24T08:50:42&#43;09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="먼저 해두고 싶은 것들 (Rev. 2)"/>
<meta name="twitter:description" content="오픈월드형 레고를 만들려면, 나처럼 나이가 든 사람은 객체 우선이 아니라 레고판이 우선이다. 얇은 녹색판."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.karkador.net/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "먼저 해두고 싶은 것들 (Rev. 2)",
      "item": "https://www.karkador.net/post/4th-my_standard/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "먼저 해두고 싶은 것들 (Rev. 2)",
  "name": "먼저 해두고 싶은 것들 (Rev. 2)",
  "description": "오픈월드형 레고를 만들려면, 나처럼 나이가 든 사람은 객체 우선이 아니라 레고판이 우선이다. 얇은 녹색판.",
  "keywords": [
    "shoutout"
  ],
  "articleBody": "서버와 도메인을 구하는 과정은 생략한다 보통 글을 보면 서버를 비교하고 구하는 과정을 가장 심도있게 다룬다. 이해한다. 그럴 수 있다. 아니 당연하다. 실제로 그냥 웹호스팅을 운영하는 것과 서버를 운영하는 것은 다르다. 근데 계정을 만들고 서버를 마련하는 절차도 다르다. 아니 다르다기보단 복잡하다. 훨씬 더 공돌이 감성에 맞춰져있다. 공돌이들에게는 응애급 난이도로 이루어져 있는 스텝이지만 - 조금이라도 지식이 있다면 버튼들이 개발자 친화적으로 배치되어있다 - 그것도 아니면 난이도가 개판인건 사실이니까.\n도메인도 굳이 깔끔한 1차 도메인을 쓸 필요가 있을까? 월 만원씩 줘가면서 좋은 도메인을 써야겠냐는 이야기이다. 목적을 생각하면 오히려 duckdns같은 있을 기능은 다 있는 무료 도메인이 훨씬 낫지 않을까? 그래서 duckdns를 쓴다. (시놀로지도 원래는 다른 도메인을 썼지만, 결국 기본으로 발급해주는 i234.me로 복귀했다.) 나중에 제대로 된 사이트를 구축한다면… 그 때는 알아서 할 수준이 되었을거라 믿는다.\n사실 나는 컴퓨터를 아예 모르는 사람들을 위해서는 글을 쓰고 싶지는 않다. 어차피 내가 쓰고 싶은 글을 휘갈기는 행위이고, 대중성을 추구할 필요도 없으며, 결국은 자기만족과 풍부한 대체품이 있기 때문이다. 그리고, 그런 사람들에게는 시청각 자료가 필요한데 그걸 찍는건 솔직히 귀찮다. IT 유튜버들이 힘을 내줬으면 하는 바람이 있다. 물론 조회수는 별로 안나오겠지. 시간대 성능비가 바닥을 치는 작업인데 말야.\n솔직히 광고차단 그거 그냥 앱 쓰면 되는데 뭐하러 DNS 서버를 구축하려고 할까? VPN은 어차피 월비용만 좀 쓰면 앱이 다 해주는거 아닌가?\n라는 생각을 하지 않으신 분들은 드디어 스타트라인에 섰다 참고로 난 OCI 기준에서 설명하려고 한다. 다른 플랫폼 사용자들은 뭐… 우린 같은 인간이니까, 그정도 응용력은 있을거라 믿겠다.\n앞에서도 썼지만,\n1. 서버를 열고 2. SSH 비밀번호를 열고 3. 도커와 컴포즈를 설치하고 나서는, 서버 내부 방화벽을 다 열어버리자.\nsudo iptables -P INPUT ACCEPT sudo iptables -P FORWARD ACCEPT sudo iptables -P OUTPUT ACCEPT sudo iptables -t nat -F sudo iptables -t mangle -F sudo iptables -F sudo iptables -X sudo netfilter-persistent save 우리에겐 오라클 방패가 있으니까, 오라클 클라우드의 서브넷 방화벽을 믿자. 참고로, 오라클 방화벽쪽은 아무것도 지우지 말자. 저 iptables는 어디까지나 서버 내부의 설정임을 또 잊지말자.\n이 시점에서 우리가 오라클 방화벽에서 열어야 할 포트는 4개, 80/81/443/3000 이다. 이는 도커에 올릴 NPM에서 사용하는 포트들이다.\n80/443: NPM Web Port → 리버스 프록시로 나중에 다른 nginx 컨테이너를 써서 웹페이지 deploy 81: NPM Admin Port → 도메인 구성해서 리버스 프록시로 묶은 후 방화벽 닫기 3000: Certbot Port → npm이 https 인증서 (Let's Encrypt 기반)를 관리하는데 사용하는 포트로서, 시스템 구축이 끝나더라도 닫으면 안 됨 앞으로 추가할 포트들이 몇 개 있긴 하다. 대외(정확히는 내가 쓸) Adguard Home에서 쓸 53, 853, 784라던가 Wireguard에서 쓸 51820이라던가. Adguard Home의 설치포트인 3000은 어차피 브릿지 모드로 꺾어쓰기도 할 것이고, 설치가 끝나면 Adguard-Home의 3000 포트는 그냥 주석처리해서 닫아버리면 된다.\nDDNS와 서버 최신화 유지 DDNS는 중요하다. NPM에서 와일드카드 인증서를 얻기 위한 DNS 챌린지와 DDNS 설정은 엄연히 다르다. 솔직히 난 이게 헷갈렸다. 두 개가 하나로 느껴졌었다.\n아니다. 아니라고. DDNS는 서버의 IP와 내 도메인을 이어주는 연결고리다. 그것도 Dynamic한 DNS를 말이지. 그럼 그 다이내믹은 어떻게 구현하냐고? 우리 서버가 클라이언트 입장이 되어 DNS서버로 ‘내 도메인의 IP는 이러합니다’라고 주기적으로 외쳐주는 행위이다. duckdns를 예로 들면, crontab을 이용하여 5분마다 한 번씩 서버 IP와 duckdns 인증키값을 함께 duckdns로 보낸다.\n사실 고정 IP가 있으면 이런 돌아가는 짓은 안해도 되겠지만, OCI를 쓰지 않거나 OCI 무료기간에 미리 고정 IP를 만들어놓지 않았거나 고정IP가 없거나 싫거나 아무튼 유동이 좋은 사람이라거나 여러 이유가 있을 것이다. DDNS의 존재 이유이다. 고정 IP가 없는 OCI 가상 인스턴스가 재부팅으로 인해 IP가 바뀌더라도 걱정이 없다. 그냥 자기가 알아서 DDNS 설정을 맞춘다. SSH를 활용할 때 마찬가지이다. IP:22가 아니라, 도메인:22로 들어간다. 사실 이정도쯤 되면 도메인 그냥 고정 하나 사도 괜찮지 않나? 라는 생각을 들게 한다.\n그러나 잊지 말자. 우리는 이걸로 돈 벌 게 아니다. 소소한 레고라이크 구축놀이를 하면서 딸려오는 이득을 챙길 뿐. 도메인이 길고 귀찮아도 광고차단 DNS 세팅은 한 번 하면 끝이다. 두 번 돌아볼 필요도 없다. 도커나 커널 업데이트를 자동으로 걸면 되는 일 아닌가?\nDuckDNS 한정 $ crontab -l 10 1 * * 6 apt update -y; apt upgrade -y 50 1 * * 6 reboot */5 * * * * /opt/duck.sh /dev/null 2\u00261 그 결과가 이거다. 5분에 한 번 dns확인을 하고, 매월 6일 1시 10분에 apt 업데이트를 하고, 당일 1시 50분에 서버 재부팅을 한다. 나는 깔끔하지 못해도 내 서버는 언제나 최신식 프로그램을 사용하도록 하고 싶은게 내새끼 마음이다. 일까? 이다. 개발 서버가 아닌 이상 솔루션을 소비하는게 주 목적인 이 서버로서는 그래도 된다. 아니 솔직히 개발 서버로도 이래야되는데, 현실의 쓴맛을 너무 깊고 진하게 봐오다보니 그걸 당당하게 얘기할 용기가 사라졌다.\n아 근데, 저건 duckdns 한정이고. 기왕이면 더 범용성이 좋은 ddclient가 더 좋지 않을까? 라고 생각해서 저것도 같이 도커로 밀어넣긴 했는데… 그건 나중에 다뤄보자.\nDDClient 도커를 쓰건, 직접 설치하건 암튼 설치해서 쓰려면 DDClient가 최고지. 이쪽은 글 순서대로만 보면 다룰 단계가 아니지만, 어차피 길라잡이 문서도 아닌데 이정도는 괜찮지 않을까 싶다. 개인적으론 포테이너 설치가 끝난 후 컨테이너 정리를 하며 서버 관리용 컴포즈로 몰아주었다.\n# ddclient.confdaemon=300syslog=yes # log update msgs to syslog#mail=root # mail all msgs to root#mail-failure=root # mail failed update msgs to rootpid=/var/run/ddclient/ddclient.pid # record PID in file.ssl=yes # use ssl-support. Works withuse=web, web=checkip.dyndns.org/, web-skip='IP Address' # found after IP Address#### CloudFlare (www.cloudflare.com)###protocol=cloudflare, \\#zone=domain.tld, \\#ttl=1, \\#login=your-login-email, \\#password=global-api-key \\#domain.tld,my.domain.tld#### Google Domains (www.google.com/domains)### protocol=googledomains,# login=my-auto-generated-username,# password=my-auto-generated-password# my.domain.tld, otherhost.domain.tld#### Duckdns (http://www.duckdns.org/)##protocol=duckdns,password=tokenmy.domain.tldNginx Proxy Manager NPM을 가장 먼저, 그것도 네트워크 host모드로 설치하는건 그만큼 이 솔루션이 가진 역할이 막중하다. 이 친구가 가져다주는 리버스 프록시의 안정감이 대단하다. 선술한 Adguard나 Wireguard같은 포트가 꼭 필요한 서비스가 아닌 이상, 외부 포트 오픈을 최소화할 수 있게 한다. 막말로 http://rakugaki.duckdns.org:21220 같은거 안봐도 된다는 뜻이다.\n게다가 이 친구, 인증서 발급/갱신도 알아서 해준다. 쓰다보면 이 쪽에 한해서는 시놀로지 OS 이상의 편리함을 자랑한다. DNS 챌린지가 가능하면 와일드카드 인증도 된다고. 시놀로지 쓰면서 가장 힘들었던게 인증서 자동발급이었는데 말이지.\nversion: '3.5' services: npm: container_name: 'npm' image: 'jc21/nginx-proxy-manager:latest' restart: always network_mode: host environment: DB_SQLITE_FILE: \"/data/database.sqlite\" volumes: - ./npm:/data - /etc/letsencrypt:/etc/letsencrypt - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro # ports: # - 81:81 원래 npm에서 쓰는 DB는 MariaDB나 PostgreSQL이지만, 솔직히 이런 솔루션이 얼마나 많은 부하를 쓰겠는가? 부하를 쓴다고 하더라도 여기에 포함된 nginx와 certbot이 문제지, DB는 그저 인증서 정보를 저장하고 프록시 엔드포인트에 대한 정보를 저장할 뿐 얼마나 많은 정보를 담는지, 얼마나 긴 로딩이 걸리는지 고려해보면 DB를 구성하는것 조차 시간 낭비라고 판단했다. 나만 그런건 아니었는지, sqlite에 대한 옵션이 존재했다.\nhost 네트워크를 사용한 것은 약간 논리적 계층문제, 그러니까 내 뇌내 설정 네트워크적으로 이렇게 정했는데, npm이 리버스 프록시 솔루션이자 게이트웨이로서 다른 도커 컨테이너들보다 앞에 있는 컨테이너로 상정했다. 어차피 80이나 443으로 뿌려주는건 서브도메인 없는 www에 한하는 것이고, 이것도 결국 별개의 nginx 컨테이너로 꺾으면 그만이니까. 게다가 npm 관리자 웹에서 쓰이는 81번 포트도 서브도메인을 이용해서 리버스 프록싱하면 막을 수 있고. 결론적으로 npm을 액세스하기 위해 직접적으로 사용하는 포트는 3000 하나 뿐인거다. 모든 설치를 끝내고, (예시로) gate.example.duckdns.org에 접속할 수 있을 때까지가 목표다.\nPortainer는 어디에? npm은 포테이너로 관리할 생각이 없다. 나처럼 이것저것 건드리다가 컴포즈 설정 미스로 npm이 내려갈 우려가 있는 성격의 소유자는 개별 컴포즈로 돌리는게 낫다. 나중에 portainer로 확인해보면 알겠지만, docker compose up -d로 올린 서비스는 포테이너에서도 로그 확인은 다 할 수 있다. 다만 스택 - 컴포즈를 포테이너에서는 스택Stack이라 부른다 - 을 편집도, 삭제도 할 수 없을 뿐. 그러면서도 watchtower에 의한 자동 업데이트는 잘 된다. 나를 위한 RO 옵션인 셈이다. 그래서 포테이너 설치도 조금 더 있다가. 구체적으로는 npm이 안정되었음을 가정한 바로 다음 글에서.\nNPM 로그인 설치 직후 초기값 ID: admin@example.com PW: changeme 일단 본인의 :81에서 로그인부터 해보자. 그 다음 자기 어드민 정보를 입력해서 본인 계정으로 만드는게 시작이다.\n여기서 할 일은 세가지이며, 우선순위는 하나를 제외하고는 특별히 없다. 왜냐면 셋 중 둘이 선행되어야 하나를 진행할 수 있기 때문이다.\n1-A. localhost:81을 gate.domain으로 리버스 프록싱하기 1-B. domain과 *.domain에 대한 https 인증서를 발급받기 2. gate.domain을 https 강제하기 다 화면 따라서 만들면 된다. 모르겠으면 다른 블로그나 브런치를 보자.\n그리고, 다시 gate.domain으로 이제 IP를 버릴 때가 됐다. 이 창에서 다른 솔루션을 위한 리버스 프록시를 걸고, 터미널에서 리드-온리 도커 컴포즈를 깔고, 그 읽기전용(으로 자칭한) 컨테이너 중에서 포테이너를 이용하여 내가 하고싶은 다른 솔루션들을 다시 올린다. 레이어가 여러겹이긴 한데, 어려운 이야기는 아니다.\n이렇게 예고편 겸 미래요약을 담아둔 이유는… 다음이 언제가 될 지 모르기 때문이다. 다음에는 portainer로 도커관리, wetty로 터미널도 웹으로 하게 관리, watchtower로 컨테이너 유지보수 자동화까지 해볼까.\n",
  "wordCount" : "1238",
  "inLanguage": "en",
  "datePublished": "2021-09-24T08:50:42+09:00",
  "dateModified": "2021-09-24T08:50:42+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.karkador.net/post/4th-my_standard/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My Rakugaki for",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.karkador.net/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.karkador.net/" accesskey="h" title="My Rakugaki for (Alt + H)">My Rakugaki for</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.karkador.net/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://www.karkador.net/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://www.karkador.net/" title="home">
                    <span>home</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      먼저 해두고 싶은 것들 (Rev. 2)<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-description">
      오픈월드형 레고를 만들려면, 나처럼 나이가 든 사람은 객체 우선이 아니라 레고판이 우선이다. 얇은 녹색판.
    </div>
    <div class="post-meta">September 24, 2021
</div>
  </header> 
  <div class="post-content"><h1 id="서버와-도메인을-구하는-과정은-생략한다">서버와 도메인을 구하는 과정은 생략한다<a hidden class="anchor" aria-hidden="true" href="#서버와-도메인을-구하는-과정은-생략한다">#</a></h1>
<p>보통 글을 보면 서버를 비교하고 구하는 과정을 가장 심도있게 다룬다. 이해한다. 그럴 수 있다. 아니 당연하다. 실제로 그냥 웹호스팅을 운영하는 것과 서버를 운영하는 것은 다르다. 근데 계정을 만들고 서버를 마련하는 절차도 다르다. 아니 다르다기보단 복잡하다. 훨씬 더 공돌이 감성에 맞춰져있다. 공돌이들에게는 응애급 난이도로 이루어져 있는 스텝이지만 - 조금이라도 지식이 있다면 버튼들이 개발자 친화적으로 배치되어있다 - 그것도 아니면 난이도가 개판인건 사실이니까.</p>
<p>도메인도 굳이 깔끔한 1차 도메인을 쓸 필요가 있을까? 월 만원씩 줘가면서 좋은 도메인을 써야겠냐는 이야기이다. 목적을 생각하면 오히려 duckdns같은 있을 기능은 다 있는 무료 도메인이 훨씬 낫지 않을까? 그래서 duckdns를 쓴다. (시놀로지도 원래는 다른 도메인을 썼지만, 결국 기본으로 발급해주는 i234.me로 복귀했다.) 나중에 제대로 된 사이트를 구축한다면… 그 때는 알아서 할 수준이 되었을거라 믿는다.</p>
<p>사실 나는 컴퓨터를 아예 모르는 사람들을 위해서는 글을 쓰고 싶지는 않다. 어차피 내가 쓰고 싶은 글을 휘갈기는 행위이고, 대중성을 추구할 필요도 없으며, 결국은 자기만족과 풍부한 대체품이 있기 때문이다. 그리고, 그런 사람들에게는 시청각 자료가 필요한데 그걸 찍는건 솔직히 귀찮다. IT 유튜버들이 힘을 내줬으면 하는 바람이 있다. 물론 조회수는 별로 안나오겠지. 시간대 성능비가 바닥을 치는 작업인데 말야.<br>
솔직히 광고차단 그거 그냥 앱 쓰면 되는데 뭐하러 DNS 서버를 구축하려고 할까? VPN은 어차피 월비용만 좀 쓰면 앱이 다 해주는거 아닌가?</p>
<h1 id="라는-생각을-하지-않으신-분들은-드디어-스타트라인에-섰다">라는 생각을 하지 않으신 분들은 드디어 스타트라인에 섰다<a hidden class="anchor" aria-hidden="true" href="#라는-생각을-하지-않으신-분들은-드디어-스타트라인에-섰다">#</a></h1>
<p>참고로 난 OCI 기준에서 설명하려고 한다. 다른 플랫폼 사용자들은 뭐… 우린 같은 인간이니까, 그정도 응용력은 있을거라 믿겠다.<br>
앞에서도 썼지만,</p>
<pre tabindex="0"><code>1. 서버를 열고
2. SSH 비밀번호를 열고
3. 도커와 컴포즈를 설치하고
</code></pre><p>나서는, 서버 내부 방화벽을 다 열어버리자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo iptables -P OUTPUT ACCEPT
sudo iptables -t nat -F
sudo iptables -t mangle -F
sudo iptables -F
sudo iptables -X
sudo netfilter-persistent save
</code></pre></div><p>우리에겐 오라클 방패가 있으니까, 오라클 클라우드의 서브넷 방화벽을 믿자. 참고로, 오라클 방화벽쪽은 아무것도 지우지 말자. 저 iptables는 어디까지나 서버 내부의 설정임을 또 잊지말자.<br>
이 시점에서 우리가 오라클 방화벽에서 열어야 할 포트는 4개, 80/81/443/3000 이다. 이는 도커에 올릴 NPM에서 사용하는 포트들이다.</p>
<pre tabindex="0"><code>80/443: NPM Web Port → 리버스 프록시로 나중에 다른 nginx 컨테이너를 써서 웹페이지 deploy
81: NPM Admin Port → 도메인 구성해서 리버스 프록시로 묶은 후 방화벽 닫기
3000: Certbot Port → npm이 https 인증서 (Let's Encrypt 기반)를 관리하는데 사용하는 포트로서, 시스템 구축이 끝나더라도 닫으면 안 됨
</code></pre><p>앞으로 추가할 포트들이 몇 개 있긴 하다. 대외(정확히는 내가 쓸) Adguard Home에서 쓸 53, 853, 784라던가 Wireguard에서 쓸 51820이라던가. Adguard Home의 설치포트인 3000은 어차피 브릿지 모드로 꺾어쓰기도 할 것이고, 설치가 끝나면 Adguard-Home의 3000 포트는 그냥 주석처리해서 닫아버리면 된다.</p>
<h1 id="ddns와-서버-최신화-유지">DDNS와 서버 최신화 유지<a hidden class="anchor" aria-hidden="true" href="#ddns와-서버-최신화-유지">#</a></h1>
<p>DDNS는 중요하다. NPM에서 와일드카드 인증서를 얻기 위한 DNS 챌린지와 DDNS 설정은 엄연히 다르다. 솔직히 난 이게 헷갈렸다. 두 개가 하나로 느껴졌었다.<br>
아니다. 아니라고. DDNS는 서버의 IP와 내 도메인을 이어주는 연결고리다. 그것도 Dynamic한 DNS를 말이지. 그럼 그 다이내믹은 어떻게 구현하냐고? 우리 서버가 클라이언트 입장이 되어 DNS서버로 &lsquo;내 도메인의 IP는 이러합니다&rsquo;라고 주기적으로 외쳐주는 행위이다. duckdns를 예로 들면, crontab을 이용하여 5분마다 한 번씩 서버 IP와 duckdns 인증키값을 함께 duckdns로 보낸다.</p>
<p>사실 고정 IP가 있으면 이런 돌아가는 짓은 안해도 되겠지만, OCI를 쓰지 않거나 OCI 무료기간에 미리 고정 IP를 만들어놓지 않았거나 고정IP가 없거나 싫거나 아무튼 유동이 좋은 사람이라거나 여러 이유가 있을 것이다. DDNS의 존재 이유이다. 고정 IP가 없는 OCI 가상 인스턴스가 재부팅으로 인해 IP가 바뀌더라도 걱정이 없다. 그냥 자기가 알아서 DDNS 설정을 맞춘다. SSH를 활용할 때 마찬가지이다. IP:22가 아니라, 도메인:22로 들어간다. 사실 이정도쯤 되면 도메인 그냥 고정 하나 사도 괜찮지 않나? 라는 생각을 들게 한다.</p>
<p>그러나 잊지 말자. 우리는 이걸로 돈 벌 게 아니다. 소소한 레고라이크 구축놀이를 하면서 딸려오는 이득을 챙길 뿐. 도메인이 길고 귀찮아도 광고차단 DNS 세팅은 한 번 하면 끝이다. 두 번 돌아볼 필요도 없다. 도커나 커널 업데이트를 자동으로 걸면 되는 일 아닌가?</p>
<h2 id="duckdns-한정">DuckDNS 한정<a hidden class="anchor" aria-hidden="true" href="#duckdns-한정">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ crontab -l
<span style="color:#ae81ff">10</span> <span style="color:#ae81ff">1</span> * * <span style="color:#ae81ff">6</span>      apt update -y; apt upgrade -y
<span style="color:#ae81ff">50</span> <span style="color:#ae81ff">1</span> * * <span style="color:#ae81ff">6</span>      reboot
*/5 * * * *     /opt/duck.sh &gt;/dev/null 2&gt;&amp;<span style="color:#ae81ff">1</span>
</code></pre></div><p>그 결과가 이거다. 5분에 한 번 dns확인을 하고, 매월 6일 1시 10분에 apt 업데이트를 하고, 당일 1시 50분에 서버 재부팅을 한다. 나는 깔끔하지 못해도 내 서버는 언제나 최신식 프로그램을 사용하도록 하고 싶은게 내새끼 마음이다. 일까? 이다. 개발 서버가 아닌 이상 솔루션을 소비하는게 주 목적인 이 서버로서는 그래도 된다. 아니 솔직히 개발 서버로도 이래야되는데, 현실의 쓴맛을 너무 깊고 진하게 봐오다보니 그걸 당당하게 얘기할 용기가 사라졌다.</p>
<p>아 근데, 저건 duckdns 한정이고. 기왕이면 더 범용성이 좋은 ddclient가 더 좋지 않을까? 라고 생각해서 저것도 같이 도커로 밀어넣긴 했는데… 그건 나중에 다뤄보자.</p>
<h2 id="ddclient">DDClient<a hidden class="anchor" aria-hidden="true" href="#ddclient">#</a></h2>
<p>도커를 쓰건, 직접 설치하건 암튼 설치해서 쓰려면 DDClient가 최고지. 이쪽은 글 순서대로만 보면 다룰 단계가 아니지만, 어차피 길라잡이 문서도 아닌데 이정도는 괜찮지 않을까 싶다. 개인적으론 포테이너 설치가 끝난 후 컨테이너 정리를 하며 서버 관리용 컴포즈로 몰아주었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-vim" data-lang="vim"># <span style="color:#a6e22e">ddclient</span>.<span style="color:#a6e22e">conf</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">daemon</span>=<span style="color:#ae81ff">300</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">syslog</span>=<span style="color:#a6e22e">yes</span>                              # <span style="color:#a6e22e">log</span> <span style="color:#a6e22e">update</span> <span style="color:#a6e22e">msgs</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">syslog</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">mail</span>=<span style="color:#a6e22e">root</span>                              # <span style="color:#a6e22e">mail</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">msgs</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">root</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">mail</span>-<span style="color:#a6e22e">failure</span>=<span style="color:#a6e22e">root</span>                      # <span style="color:#a6e22e">mail</span> <span style="color:#a6e22e">failed</span> <span style="color:#a6e22e">update</span> <span style="color:#a6e22e">msgs</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">root</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">pid</span>=<span style="color:#e6db74">/var/</span><span style="color:#a6e22e">run</span><span style="color:#e6db74">/ddclient/</span><span style="color:#a6e22e">ddclient</span>.<span style="color:#a6e22e">pid</span>      # <span style="color:#a6e22e">record</span> <span style="color:#a6e22e">PID</span> <span style="color:#a6e22e">in</span> <span style="color:#a6e22e">file</span>.<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">ssl</span>=<span style="color:#a6e22e">yes</span>                                 # <span style="color:#a6e22e">use</span> <span style="color:#a6e22e">ssl</span>-<span style="color:#a6e22e">support</span>.  <span style="color:#a6e22e">Works</span> <span style="color:#a6e22e">with</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">use</span>=<span style="color:#a6e22e">web</span>, <span style="color:#a6e22e">web</span>=<span style="color:#a6e22e">checkip</span>.<span style="color:#a6e22e">dyndns</span>.<span style="color:#a6e22e">org</span>/, <span style="color:#a6e22e">web</span>-<span style="color:#a6e22e">skip</span>=<span style="color:#e6db74">&#39;IP Address&#39;</span> # <span style="color:#a6e22e">found</span> <span style="color:#a6e22e">after</span> <span style="color:#a6e22e">IP</span> <span style="color:#a6e22e">Address</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>## <span style="color:#a6e22e">CloudFlare</span> (<span style="color:#a6e22e">www</span>.<span style="color:#a6e22e">cloudflare</span>.<span style="color:#a6e22e">com</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">protocol</span>=<span style="color:#a6e22e">cloudflare</span>,        \<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">zone</span>=<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span>,            \<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">ttl</span>=<span style="color:#ae81ff">1</span>,                      \<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">login</span>=<span style="color:#a6e22e">your</span>-<span style="color:#a6e22e">login</span>-<span style="color:#a6e22e">email</span>,     \<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">password</span>=<span style="color:#a6e22e">global</span>-<span style="color:#a6e22e">api</span>-<span style="color:#a6e22e">key</span>     \<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>#<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span>,<span style="color:#a6e22e">my</span>.<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>## <span style="color:#a6e22e">Google</span> <span style="color:#a6e22e">Domains</span> (<span style="color:#a6e22e">www</span>.<span style="color:#a6e22e">google</span>.<span style="color:#a6e22e">com</span>/<span style="color:#a6e22e">domains</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span># <span style="color:#a6e22e">protocol</span>=<span style="color:#a6e22e">googledomains</span>,<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span># <span style="color:#a6e22e">login</span>=<span style="color:#a6e22e">my</span>-<span style="color:#a6e22e">auto</span>-<span style="color:#a6e22e">generated</span>-<span style="color:#a6e22e">username</span>,<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span># <span style="color:#a6e22e">password</span>=<span style="color:#a6e22e">my</span>-<span style="color:#a6e22e">auto</span>-<span style="color:#a6e22e">generated</span>-<span style="color:#a6e22e">password</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span># <span style="color:#a6e22e">my</span>.<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span>, <span style="color:#a6e22e">otherhost</span>.<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>## <span style="color:#a6e22e">Duckdns</span> (<span style="color:#a6e22e">http</span>:<span style="color:#e6db74">//</span><span style="color:#a6e22e">www</span>.<span style="color:#a6e22e">duckdns</span>.<span style="color:#a6e22e">org</span>/)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>##<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">protocol</span>=<span style="color:#a6e22e">duckdns</span>,<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">password</span>=&lt;<span style="color:#a6e22e">token</span>&gt;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#a6e22e">my</span>.<span style="color:#a6e22e">domain</span>.<span style="color:#a6e22e">tld</span><span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h1 id="nginx-proxy-manager">Nginx Proxy Manager<a hidden class="anchor" aria-hidden="true" href="#nginx-proxy-manager">#</a></h1>
<p>NPM을 가장 먼저, 그것도 네트워크 host모드로 설치하는건 그만큼 이 솔루션이 가진 역할이 막중하다. 이 친구가 가져다주는 리버스 프록시의 안정감이 대단하다. 선술한 Adguard나 Wireguard같은 포트가 꼭 필요한 서비스가 아닌 이상, 외부 포트 오픈을 최소화할 수 있게 한다. 막말로 <a href="http://rakugaki.duckdns.org:21220">http://rakugaki.duckdns.org:21220</a> 같은거 안봐도 된다는 뜻이다.<br>
게다가 이 친구, 인증서 발급/갱신도 알아서 해준다. 쓰다보면 이 쪽에 한해서는 시놀로지 OS 이상의 편리함을 자랑한다. DNS 챌린지가 가능하면 와일드카드 인증도 된다고. 시놀로지 쓰면서 가장 힘들었던게 인증서 자동발급이었는데 말이지.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">version</span>: <span style="color:#e6db74">&#39;3.5&#39;</span>
<span style="color:#f92672">services</span>:
  <span style="color:#f92672">npm</span>:
    <span style="color:#f92672">container_name</span>: <span style="color:#e6db74">&#39;npm&#39;</span>
    <span style="color:#f92672">image</span>: <span style="color:#e6db74">&#39;jc21/nginx-proxy-manager:latest&#39;</span>
    <span style="color:#f92672">restart</span>: <span style="color:#ae81ff">always</span>
    <span style="color:#f92672">network_mode</span>: <span style="color:#ae81ff">host</span>
    <span style="color:#f92672">environment</span>:
      <span style="color:#f92672">DB_SQLITE_FILE</span>: <span style="color:#e6db74">&#34;/data/database.sqlite&#34;</span>
    <span style="color:#f92672">volumes</span>:
      - <span style="color:#ae81ff">./npm:/data</span>
      - <span style="color:#ae81ff">/etc/letsencrypt:/etc/letsencrypt</span>
      - <span style="color:#ae81ff">/etc/timezone:/etc/timezone:ro</span>
      - <span style="color:#ae81ff">/etc/localtime:/etc/localtime:ro</span>
        <span style="color:#75715e">#    ports:</span>
        <span style="color:#75715e">#      - 81:81</span>
</code></pre></div><p>원래 npm에서 쓰는 DB는 MariaDB나 PostgreSQL이지만, 솔직히 이런 솔루션이 얼마나 많은 부하를 쓰겠는가? 부하를 쓴다고 하더라도 여기에 포함된 nginx와 certbot이 문제지, DB는 그저 인증서 정보를 저장하고 프록시 엔드포인트에 대한 정보를 저장할 뿐 얼마나 많은 정보를 담는지, 얼마나 긴 로딩이 걸리는지 고려해보면 DB를 구성하는것 조차 시간 낭비라고 판단했다. 나만 그런건 아니었는지, sqlite에 대한 옵션이 존재했다.<br>
host 네트워크를 사용한 것은 약간 논리적 계층문제, 그러니까 내 뇌내 설정 네트워크적으로 이렇게 정했는데, npm이 리버스 프록시 솔루션이자 게이트웨이로서 다른 도커 컨테이너들보다 앞에 있는 컨테이너로 상정했다. 어차피 80이나 443으로 뿌려주는건 서브도메인 없는 www에 한하는 것이고, 이것도 결국 별개의 nginx 컨테이너로 꺾으면 그만이니까. 게다가 npm 관리자 웹에서 쓰이는 81번 포트도 서브도메인을 이용해서 리버스 프록싱하면 막을 수 있고. 결론적으로 npm을 액세스하기 위해 직접적으로 사용하는 포트는 3000 하나 뿐인거다. 모든 설치를 끝내고, (예시로) gate.example.duckdns.org에 접속할 수 있을 때까지가 목표다.</p>
<h2 id="portainer는-어디에">Portainer는 어디에?<a hidden class="anchor" aria-hidden="true" href="#portainer는-어디에">#</a></h2>
<p>npm은 포테이너로 관리할 생각이 없다. 나처럼 이것저것 건드리다가 컴포즈 설정 미스로 npm이 내려갈 우려가 있는 성격의 소유자는 개별 컴포즈로 돌리는게 낫다. 나중에 portainer로 확인해보면 알겠지만, docker compose up -d로 올린 서비스는 포테이너에서도 로그 확인은 다 할 수 있다. 다만 스택 - 컴포즈를 포테이너에서는 스택Stack이라 부른다 - 을 편집도, 삭제도 할 수 없을 뿐. 그러면서도 watchtower에 의한 자동 업데이트는 잘 된다. 나를 위한 RO 옵션인 셈이다. 그래서 포테이너 설치도 조금 더 있다가. 구체적으로는 npm이 안정되었음을 가정한 바로 다음 글에서.</p>
<h2 id="npm-로그인">NPM 로그인<a hidden class="anchor" aria-hidden="true" href="#npm-로그인">#</a></h2>
<pre tabindex="0"><code>설치 직후 초기값
ID: admin@example.com
PW: changeme
</code></pre><p>일단 본인의 &lt;OCI 외부 IP&gt;:81에서 로그인부터 해보자. 그 다음 자기 어드민 정보를 입력해서 본인 계정으로 만드는게 시작이다.<br>
여기서 할 일은 세가지이며, 우선순위는 하나를 제외하고는 특별히 없다. 왜냐면 셋 중 둘이 선행되어야 하나를 진행할 수 있기 때문이다.</p>
<pre tabindex="0"><code>1-A. localhost:81을 gate.domain으로 리버스 프록싱하기
1-B. domain과 *.domain에 대한 https 인증서를 발급받기
2. gate.domain을 https 강제하기
</code></pre><p>다 화면 따라서 만들면 된다. 모르겠으면 다른 블로그나 브런치를 보자.</p>
<h2 id="그리고-다시-gatedomain으로">그리고, 다시 gate.domain으로<a hidden class="anchor" aria-hidden="true" href="#그리고-다시-gatedomain으로">#</a></h2>
<p>이제 IP를 버릴 때가 됐다. 이 창에서 다른 솔루션을 위한 리버스 프록시를 걸고, 터미널에서 리드-온리 도커 컴포즈를 깔고, 그 읽기전용(으로 자칭한) 컨테이너 중에서 포테이너를 이용하여 내가 하고싶은 다른 솔루션들을 다시 올린다. 레이어가 여러겹이긴 한데, 어려운 이야기는 아니다.</p>
<p>이렇게 예고편 겸 미래요약을 담아둔 이유는… 다음이 언제가 될 지 모르기 때문이다. 다음에는 portainer로 도커관리, wetty로 터미널도 웹으로 하게 관리, watchtower로 컨테이너 유지보수 자동화까지 해볼까.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.karkador.net/tags/shoutout/">shoutout</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://www.karkador.net/">My Rakugaki for</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
